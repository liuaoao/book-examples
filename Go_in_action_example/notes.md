# 第一章：关于Go语言的介绍
1. 源代码在：https://github/com/goinaction/code下载
2. Go语言的特点：
* 高性能的语言，同事也让开发更快速
* 语法简洁到只有几个关键字，便于记忆
* 编译器速度非常快
* 类型系统简单且高效：灵活、无继承的类型系统，但依然支持面向对象开发
* 自带垃圾回收期，不需要用户自己管理内存
* 对并发的支持：goroutine、通道（channel）
3. Go Playground：http://play.golang.org 可以在浏览器中编辑并运行Go语言代码
```Go
# Go程序都组织成包
package main
# import语句用于导入外部代码，标准库中的fmt包用于格式化并输出数据
import "fmt"
# 像C语言一样，main函数是程序执行的入口
func main() {
	fmt.Println("Hello, World!")
}

```

# 第2章：快速开始一个Go程序
1. main函数保存在名为main的包里，如果main函数不在main包里，构建工具就不会生成可执行的文件
2. Go语言的每个代码文件都属于一个包，main.go也不例外
3. 一个包定义一组编译过的代码，包的名字类似命名空间，可以用来间接访问包内声明和标识符，这个特性可以将不同包中定义的同名标识符区别开
4. 关键字import就是导入一段代码，让用户可以访问其中的标识符，如类型、函数、常量和接口
5. 所有处于同一文件夹的代码文件，必须使用同一个包名，按照管理，包和文件夹同名
6. 导入路径前加_下划线，是为了让Go语言对包进行初始化操作，但是并不适用包里的标识符。因为Go语言不允许声明导入包且不使用。下划线让编译器接受这类导入，并且调用包内所有代码文件的init函数
7. 在Go语言中，所有变量都被初始化为其零值，数值类型的零值是0，字符串类型的零值是空字符串，布尔型的零值是false，指针的零值是nil
8. 在Go语言中，使用关键字func声明函数，关键字后面紧跟着函数名、参数以及返回值
9. 简化变量声明运算符(:=)，这个运算符用于声明一个变量，同时给这个变量赋予初始值。和其他使用var声明的变量没有任何区别
10. 在Go语言中，make关键字用于创建切片、映射（map）和通道（channel），这三种数据结构在Go中都是引用类型。make函数的语法如下：make(Type, size)
11. 关键字range可以用于迭代数组、字符串、切片、映射和通道。使用for range迭代切片时，每次迭代会返回两个值，第一个是迭代的元素在切片中的索引位置，第二个是元素值的一个副本
12. 一个goroutine是一个独立于其他函数运行的函数，使用关键字go来启动一个goroutine，并对这个goroutine做并发调度。（就是并发运行的意思吧）
13. 匿名函数是指没有明确声明名字的函数
14. Go语言可以使用闭包，因为闭包我们可以共享同样的变量
15. import "encoding/json" 不管导入路径是什么样，并不会改变包名，我们在访问json包内的函数时，依旧是指定json这个名字
16. 关键字defer会安排随后的函数他调用在函数返回时才执行，例如file.close()，当前函数返回了，才执行关闭文件的操作
17. 如果声明函数的时候带有接收者，则意味着声明了一个方法，这个方法会和指定的接收者类型绑在一起。（利用这个来实现面向对象？）

# 第三章：打包和工具链
1. Go语言的程序都会组织成若干组文件，每组文件都被称为一个包
2. 给包机器目录命名时，应使用简介、清晰并且全部小写的名字
3. 命名包的名字为main时，有特殊含义，会查找main()函数，同时有的话会创建可执行文件
4. import导入：先在Go的安装目录下查找，再去GOPATH中逐一查找
5. 远程导入：如import "github.com/spf13/viper"，需要使用go get命令获取。go get命令有递归性，这个命令会扫描某个包的源码树，获取能找到的所有依赖包。
6. 命名导入：如import fmt "mylib/fmt"可以重命名自己的包，避免多个相同名称的包
7. 当导入一个未引用的包时，Go编译会报错，所以如果需要导入一个包，但是不需要引用它的标识符，可以用空白标识符_来重命名这个导入。
8.一旦导入了这个包，就会执行init()函数来做初始化。如果需要初始化，但是不需要引用其标识符，就要用到7中的空白标识符
9. go工具：直接在终端键入go查看。
    (1). go build：编译
    (2). go clean：删除编译生成的可执行文件
    (3). go run：编译+执行
    (4). go vet：可以发现一些常见的错误
    (5). go fmt：格式化你的代码
    (6). go doc：查看依赖包的文档
10. godoc -http=6060来启动go的文档服务器，可以在网页上查看所有安装的依赖包的文档。但是在v1.13之后需要安装了godoc才能使用
11. 依赖管理：gb构建工具

# 第四章：数组、切片和映射
1. 数组是一个长度固定的数据类型，用于存储一段具有的类型的元素的连续块。声明数组时需要指定存储的数据类型，以及需要存储的元素的数量，这个数量就是数组的长度。一旦声明，数组存储的数据类型和数组长度就不能改变了。
2. 声明和初始化：例如：var array [5]int就是声明一个包含5个元素的整型数组，数组内每个元素都初始化为对应类型的零值。这个例子就是5个0。
3. 自动计算数组长度：如果使用...替代数组的长度，那么Go会根据初始化的数组元素来决定数组的长度：array := [...]int{10, 20, 30, 40, 50}
4. 声明数组并指定特定元素：例如array := [5]int{1:10, 2:20}就会等到一个[0,10,20,0,0]的数组
5. 多维数组：数组只有一个维度、但可以组合多个数组创建多为数组：var array [4][2]int
6. 可以使用之神在函数间传递大数组
7. 切片是一种数据结构，这种数据结构便于使用和管理数据集合，切片是围绕动态数组的概念构建的，可以按需自动增长和缩小，切片的动态增长使用append来实现。
8. 一种创建切片的方式是使用内置的make函数。例如创建一个长度和容量都是5的切片: slice := make([]string, 5)。又如创建一个长度3，容量5的切片: slice := make([]int, 3, 5)，意味着切片可以访问3个元素，剩下的2个元素可以在后续操作中合并到切片，底层数组有5个元素。不允许创建一个容量小于长度的切片。
9. 另一种创建切片的方式是使用切片字面量，和创建数组类似，只是不需要指定[]运算符里的值
10. 创建nil切片：var slice []int，指针是nil，长度和容量都是0，例如函数要求返回一个切片但是发生异常的时候会用到。创建空切片：slice := make([]int, 0)。指针是地址，长度和容量都是0。不管是nil切片还是空切片，对其使用append、len和cap的效果都是一样的。
11. 切片的操作：用[]操作符就可以某个元素的值。
12. 对于底层数组容量是k的切片slice[i:j]来说，长度：j-i，容量k-i。
13. 如果切片的底层数组没有足够的可用容量，append函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值；
14. 创建切片时的第三个索引，可以用来限制新切片的容量。slice := source[i:j:k]，即新切片的容量为k-i，长度为j-1。
15. 设置长度和容量一致的好处：在新切片追加的时候，不会把新值修改到source原切片中去。
16. 迭代切片：for index, value in range slice {}。range会返回当前迭代的索引位置、和该位置对应元素的一份副本（而不是对元素的引用）。如果不需要用到索引值，可以用占位字符来代替index。
17. 内置函数len和cap可以用来处理数组、切片和通道；len返回切片的长度，cap返回切片的容量。
18. 多维切片：原理是一样的
19. 映射：是一种数据结构，用于存储一系列无序的键值对。无序的原因是映射实现了散列表
20. 映射的创建和初始化：可以使用内置的make函数：dict := make(map[string]int)意为创建一个映射，键的类型是string，值的类型是int。
21. 映射的键的类型可以是内置的类型，也可以是结构类型，只要可以用==来做比较，切片、函数以及包含切片的结构类型由于具有引用语义，不能作为应映射的键（流畅的python里解析是因为不可哈希）
22. 声明一个nil映射： var colors map[string]string。（不是nil的话后面有{}的），nil映射不能存储键值对
23. 判断键是否存在：value, exists := colors["Blue"]，在Go语言中，即使键不存在，也会返回一个零值
24. 对于map来说，range返回的是键值对for key, value := range colors {}
25. 删除一个键值对：delete(colors, "Coral")
26. 在函数间传递一个映射，不会制造出该映射的副本，做的修改之后，所有对这个映射的引用都会察觉到这个修改。
