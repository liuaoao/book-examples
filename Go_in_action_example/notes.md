# 第一章：关于Go语言的介绍
1. 源代码在：https://github/com/goinaction/code下载
2. Go语言的特点：
* 高性能的语言，同事也让开发更快速
* 语法简洁到只有几个关键字，便于记忆
* 编译器速度非常快
* 类型系统简单且高效：灵活、无继承的类型系统，但依然支持面向对象开发
* 自带垃圾回收期，不需要用户自己管理内存
* 对并发的支持：goroutine、通道（channel）
3. Go Playground：http://play.golang.org 可以在浏览器中编辑并运行Go语言代码
```Go
# Go程序都组织成包
package main
# import语句用于导入外部代码，标准库中的fmt包用于格式化并输出数据
import "fmt"
# 像C语言一样，main函数是程序执行的入口
func main() {
	fmt.Println("Hello, World!")
}

```

# 第2章：快速开始一个Go程序
1. main函数保存在名为main的包里，如果main函数不在main包里，构建工具就不会生成可执行的文件
2. Go语言的每个代码文件都属于一个包，main.go也不例外
3. 一个包定义一组编译过的代码，包的名字类似命名空间，可以用来间接访问包内声明和标识符，这个特性可以将不同包中定义的同名标识符区别开
4. 关键字import就是导入一段代码，让用户可以访问其中的标识符，如类型、函数、常量和接口
5. 所有处于同一文件夹的代码文件，必须使用同一个包名，按照管理，包和文件夹同名
6. 导入路径前加_下划线，是为了让Go语言对包进行初始化操作，但是并不适用包里的标识符。因为Go语言不允许声明导入包且不使用。下划线让编译器接受这类导入，并且调用包内所有代码文件的init函数
7. 在Go语言中，所有变量都被初始化为其零值，数值类型的零值是0，字符串类型的零值是空字符串，布尔型的零值是false，指针的零值是nil
8. 在Go语言中，使用关键字func声明函数，关键字后面紧跟着函数名、参数以及返回值
9. 简化变量声明运算符(:=)，这个运算符用于声明一个变量，同时给这个变量赋予初始值。和其他使用var声明的变量没有任何区别
10. 在Go语言中，make关键字用于创建切片、映射（map）和通道（channel），这三种数据结构在Go中都是引用类型。make函数的语法如下：make(Type, size)
11. 关键字range可以用于迭代数组、字符串、切片、映射和通道。使用for range迭代切片时，每次迭代会返回两个值，第一个是迭代的元素在切片中的索引位置，第二个是元素值的一个副本
12. 一个goroutine是一个独立于其他函数运行的函数，使用关键字go来启动一个goroutine，并对这个goroutine做并发调度。（就是并发运行的意思吧）
13. 匿名函数是指没有明确声明名字的函数
14. Go语言可以使用闭包，因为闭包我们可以共享同样的变量
15. import "encoding/json" 不管导入路径是什么样，并不会改变包名，我们在访问json包内的函数时，依旧是指定json这个名字
16. 关键字defer会安排随后的函数他调用在函数返回时才执行，例如file.close()，当前函数返回了，才执行关闭文件的操作
17. 如果声明函数的时候带有接收者，则意味着声明了一个方法，这个方法会和指定的接收者类型绑在一起。（利用这个来实现面向对象？）

# 第三章：打包和工具链
1. Go语言的程序都会组织成若干组文件，每组文件都被称为一个包
2. 给包机器目录命名时，应使用简介、清晰并且全部小写的名字
3. 命名包的名字为main时，有特殊含义，会查找main()函数，同时有的话会创建可执行文件
4. import导入：先在Go的安装目录下查找，再去GOPATH中逐一查找
5. 远程导入：如import "github.com/spf13/viper"，需要使用go get命令获取。go get命令有递归性，这个命令会扫描某个包的源码树，获取能找到的所有依赖包。
6. 命名导入：如import fmt "mylib/fmt"可以重命名自己的包，避免多个相同名称的包
7. 当导入一个未引用的包时，Go编译会报错，所以如果需要导入一个包，但是不需要引用它的标识符，可以用空白标识符_来重命名这个导入。
8.一旦导入了这个包，就会执行init()函数来做初始化。如果需要初始化，但是不需要引用其标识符，就要用到7中的空白标识符
9. go工具：直接在终端键入go查看。
    (1). go build：编译
    (2). go clean：删除编译生成的可执行文件
    (3). go run：编译+执行
    (4). go vet：可以发现一些常见的错误
    (5). go fmt：格式化你的代码
    (6). go doc：查看依赖包的文档
10. godoc -http=6060来启动go的文档服务器，可以在网页上查看所有安装的依赖包的文档。但是在v1.13之后需要安装了godoc才能使用
11. 依赖管理：gb构建工具

# 第四章：数组、切片和映射

## 数组
1. 数组是一个长度固定的数据类型，用于存储一段具有的类型的元素的连续块。声明数组时需要指定存储的数据类型，以及需要存储的元素的数量，这个数量就是数组的长度。一旦声明，数组存储的数据类型和数组长度就不能改变了。
2. 声明和初始化：例如：var array [5]int就是声明一个包含5个元素的整型数组，数组内每个元素都初始化为对应类型的零值。这个例子就是5个0。
3. 自动计算数组长度：如果使用...替代数组的长度，那么Go会根据初始化的数组元素来决定数组的长度：array := [...]int{10, 20, 30, 40, 50}
4. 声明数组并指定特定元素：例如array := [5]int{1:10, 2:20}就会等到一个[0,10,20,0,0]的数组
5. 多维数组：数组只有一个维度、但可以组合多个数组创建多为数组：var array [4][2]int
6. 可以使用之神在函数间传递大数组

## 切片
7. 切片是一种数据结构，这种数据结构便于使用和管理数据集合，切片是围绕动态数组的概念构建的，可以按需自动增长和缩小，切片的动态增长使用append来实现。
8. 一种创建切片的方式是使用内置的make函数。例如创建一个长度和容量都是5的切片: slice := make([]string, 5)。又如创建一个长度3，容量5的切片: slice := make([]int, 3, 5)，意味着切片可以访问3个元素，剩下的2个元素可以在后续操作中合并到切片，底层数组有5个元素。不允许创建一个容量小于长度的切片。
9. 另一种创建切片的方式是使用切片字面量，和创建数组类似，只是不需要指定[]运算符里的值
10. 创建nil切片：var slice []int，指针是nil，长度和容量都是0，例如函数要求返回一个切片但是发生异常的时候会用到。创建空切片：slice := make([]int, 0)。指针是地址，长度和容量都是0。不管是nil切片还是空切片，对其使用append、len和cap的效果都是一样的。
11. 切片的操作：用[]操作符就可以某个元素的值。
12. 对于底层数组容量是k的切片slice[i:j]来说，长度：j-i，容量k-i。
13. 如果切片的底层数组没有足够的可用容量，append函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值；
14. 创建切片时的第三个索引，可以用来限制新切片的容量。slice := source[i:j:k]，即新切片的容量为k-i，长度为j-1。
15. 设置长度和容量一致的好处：在新切片追加的时候，不会把新值修改到source原切片中去。
16. 迭代切片：for index, value in range slice {}。range会返回当前迭代的索引位置、和该位置对应元素的一份副本（而不是对元素的引用）。如果不需要用到索引值，可以用占位字符来代替index。
17. 内置函数len和cap可以用来处理数组、切片和通道；len返回切片的长度，cap返回切片的容量。
18. 多维切片：原理是一样的

## 映射
19. 映射：是一种数据结构，用于存储一系列无序的键值对。无序的原因是映射实现了散列表
20. 映射的创建和初始化：可以使用内置的make函数：dict := make(map[string]int)意为创建一个映射，键的类型是string，值的类型是int。
21. 映射的键的类型可以是内置的类型，也可以是结构类型，只要可以用==来做比较，切片、函数以及包含切片的结构类型由于具有引用语义，不能作为应映射的键（流畅的python里解析是因为不可哈希）
22. 声明一个nil映射： var colors map[string]string。（不是nil的话后面有{}的），nil映射不能存储键值对
23. 判断键是否存在：value, exists := colors["Blue"]，在Go语言中，即使键不存在，也会返回一个零值
24. 对于map来说，range返回的是键值对for key, value := range colors {}
25. 删除一个键值对：delete(colors, "Coral")
26. 在函数间传递一个映射，不会制造出该映射的副本，做的修改之后，所有对这个映射的引用都会察觉到这个修改。


# 第五章：Go语言的类型系统

## 类型
1. Go语言允许用户定义类型，当用户声明一个新类型时，这个声明就给编译器提供了一个框架，告知必要的内存大小和表示信息，声明后的类型和内置类型的运作方式类似。最常用关键字struct来声明类型。
2. 创建一个变量并初始化为零值，习惯是使用关键字var，这种用法是为了更明确地表示一个变量被设置为零值
3. 结构类型的声明有两种方式，一种是字段名与值隔开，每一行以逗号结尾，对声明顺序没有要求。更常用的声明形式是写在一行里，只需要写值，值的顺序必须和结构类型的顺序一致，结尾不需要逗号。
3. 另一种声明用户定义的类型方法是，基于一个已有的类型，将其作为新类型的类型说明，例如：var Duration int64.
4. 方法能给用户定义的类型添加新的行为。方法实际上也是函数，只是在声明时，在关键字func和方法名之间增加了一个参数。
5. 关键字func和函数名之间的参数被称为接收者，将函数与接收者的类型绑在一起，如果一个函数有接收者，这个函数就被成为方法。有两种类型的接收者：值接收者和指针接收者。
6. 值接收者使用值的副本来调用方法，而指针接收者使用实际值来调用方法。（就是值接收者的方法不会改变原值，而指针接收者的方法会改变原值）。另外，Go语言即允许使用值，也允许使用指针来调用方法，不必严格副歌接收者的类型（Go语言会自动把值和指针转换适应所需的接收者）
7. 内置类型是由语言提供的类型，分别是数值类型、字符串类型和布尔类型，本质上是原始的类型。当这些类型传给方法或者函数时，应该传递一个对应值的副本
8. Go语言中的引用类型有如下几个：切片、映射、通道、接口和函数类型。当声明这些变量时，创建的变量被成为标头（header）值，每个引用类型还包含一组独特的字段，用于管理底层数据接口结构，因为标头值时为复制而设计的。标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本质上就是共享底层数据结构。但是，在函数传入一个引用类型时，调用者是将引用类型的值的副本传入这个函数，而不是通过引用共享给这个函数，这个方法也适用于函数的返回值。所以，引用类型的值在其他方面像原始的数据类型的值一样对待。
9. 结构类型：可以用来描述一组数据值，这些值的本质可以是原始的，也可以是非原始的。结构类型在大多数情况下是非原始的，这时，对这个类型的值做增加、删除时应该更改值本身，修改值本身时，需要用指针来共享这个值。

## 接口

10. 多态是指代码可以根据类型的具体实现采取不同行为的能力。如果一个类型实现了某个接口，所有使用这个接口的地方，都可以只是这个类型的值。
11. 在Go语言中，接口（interface）是一种抽象类型，用于定义一组方法的集合。接口定义了一种契约，规定了实现该接口的具体类型必须提供哪些方法。任何类型只要实现了接口中定义的所有方法，就被认为是实现了该接口。任何类型只要包含了接口中定义的所有方法，就被视为实现了该接口。不需要显式声明实现，只要方法的签名匹配即可。接口在实际编程中广泛用于实现多态性和代码复用。通过接口，可以编写与具体类型无关的通用代码，提高代码的灵活性。在这个例子中，CallMethods 函数接受一个实现了 MyInterface 接口的参数，并调用了接口中定义的方法。虽然 CallMethods 函数并不知道具体传递的是什么类型，但它可以调用接口中定义的方法，这就是接口的一种多态性表现。定义接口，规定一组方法的集合。  
    a.任何类型只要实现了接口中的方法，就被认为是实现了该接口。  
    b.接口提供了一种多态的机制，使得可以编写与具体类型无关的通用代码。  
    c.接口的实现是隐式的，无需显式声明实现关系。  
    d.接口在Go语言中是一种非常强大而灵活的机制，它促进了代码的组织和扩展，支持了面向接口的编程范式。
```Go
type MyInterface interface {
    Method1() // 方法1
    Method2() // 方法2
    // ...
}
type MyType struct {
    // 类型的字段
}

// MyType 实现了 MyInterface 接口的所有方法
func (m MyType) Method1() {
    // 实现 Method1 的逻辑
}

func (m MyType) Method2() {
    // 实现 Method2 的逻辑
}
func CallMethods(i MyInterface) {
    // 调用接口的方法
    i.Method1()
    i.Method2()
}

func main() {
    // 创建 MyType 类型的实例
    myInstance := MyType{}

    // 将 MyType 实例传递给 CallMethods 函数
    CallMethods(myInstance)
}
```
12. 接口是用来定义行为的类型，这些被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现。
如果用户定义的类型实现了某个接口类型声明的一组方法，那么这个类型的值就可以赋给这个接口类型的值。这个赋值会把用户定义的类型的值，存入接口类型的值。
13. 对接口值方法的调用会执行接口值里存储的用户定义的类型的值对应的方法。因为任何用户定义的星泪都可以实现任何接口，所以对接口值方法的调用自然就是一种堕胎。这个关系里，用户定义的类型通常叫做实体类型。并不是所有值都完全等同，用户定义的类型的值或指针要满足接口的实现，需要遵循一些规则。
14. 方法集定义了一组关联到给定类型的值或者指针的方法，定义方法时使用的接收者的类型决定了这个方法时关联到值，还是关联到指针，还是两个都关联。
15. 规范里描述的方法集

|Values|Method Receivers|  
|-----|---|  
|T |(t T) |  
|*T | (t T) and (t *T)|  

从接收者类型的角度来看方法集：  

|Method Receivers|Values|  
|-----|---|  
|(t T) |T and *T|  
|(t *T) | *T|  

这个规则说：如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能实现对应的接口。如果使用值接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。  
16. 因为不是总能获取一个值的地址，所以值的方法集，只包括了使用值接收者实现的方法。
17. Go允许用户扩展或修改已有类型，这个功能对代码复用很重要，在修改已有类型以符合新类型的时候也很重要，这个功能是通过嵌入类型（type embedding）完成的。嵌入类型是将已有的类型直接声明在新的结构类型里，被嵌入的类型被称为新的外部类型的内部类型。要嵌入一个类型，只需要声明这个类型的名字就可以了。
18. 对于外部类型来说，内部类型总是存在的，这就意味着，虽然没有指定内部类型对应的字段名，还是可以使用内部类型的类型名，来访问到内部类型的值。这就是内部类型的提升。由于内部类型的标识符提升到了外部类型，我们可以直接通过外部类型的值来访问内部类型的标识符，内部类型实现的接口会自动提升到外部类型。（具体实现可以看listing50.go和listing56.go）。如果外部类型和内部类型实现了同一个方法，那么内部类型将不会被提升（具体实现看listing60.go）。

## 标识符
19. Go语言支持从包里公开或者隐藏标识符（from chatgpt：在编程语言中，标识符（Identifier）是用来标识某个实体的名称。这可以是变量、常量、函数、类型、包等的名称）。通过这个功能，让用户按照自己的规则控制标识符的可见性。有时候你可能不希望公开包里的某个类型、函数或者方法这样的标识符，这时就需要将这些标识符声明为包外不可见、未公开的。
20. 当一个标识符以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见，如果一个标识符以大写字母开头，这个标识符就是公开的，即包外的代码可见。

# 第六章：并发
## 概念
1. Go语言的语法和运行时直接内置了对并发的支持。Go语言里的并发指的是能让某个函数独立于其他函数运行的能力，当一个函数创建未goroutine时，Go会将其视为一个独立的工作单元。这个单元会被调度到可用的逻辑处理器上执行。
2. Go元的并发同步模型来自一个叫做通信顺序进程（Communicating Sequential Processes, CSP）的范型（paradigm）。CSP是一种消息传递模型，通过在goroutine之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。用于在goroutine之间同步和传递数据的关键数据类型叫做通道（channel）。
3. 线程（Thread）和进程（process）：一个进程通常被分配这些常用资源：内存地址空间、文件和设备的句柄以及线程，一个线程是一个执行空间，这个空间会被操作系统调度来运行函数中所写的代码。每个进程至少包含一个线程，每个进程的初始线程被称为主线程。
4. 并发（concurrency）不是并行（parallelism），并行是让不同的代码片段同时在不同的物理处理器上执行，并行的关键是同时做很多事情。而并发是指同时管理很多事情，这些事情可能只做了一般就被暂停去做别的事情了。在很多情况下，并发的效果比并行好，这是“使用较少的资源做更多的事情”的哲学。
5. 在Go语言中，"逻辑处理器"通常指的是并发执行代码的单元，即goroutine在物理处理器（CPU核心）上执行的逻辑单位。每个逻辑处理器都与一个操作系统线程（OS thread）关联。这种设计使得Go语言可以更好地利用多核处理器，通过并发执行来提高程序的性能。
6. from chatgpt：Go语言的运行时系统（runtime）负责在物理处理器上调度和管理多个逻辑处理器。当你启动一个goroutine时，它会被调度到一个逻辑处理器上执行，而不是直接绑定到一个特定的物理处理器。这种方式允许Go语言运行时系统动态地将goroutines分配给不同的逻辑处理器，以充分利用可用的计算资源。在Go语言中，你可以通过runtime包来获取逻辑处理器的数量：
```Go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	numCPU := runtime.NumCPU()
	fmt.Printf("Number of logical processors: %d\n", numCPU)
}
```

## 竞争状态
7. 调用runtime包中的GOMAXPROCS函数，这个函数允许程序更改调度器可以使用的逻辑处理器的数量。sync包中的WaitGroup是一个计数信号量，可以记录并维护运行的goroutine，如果WaitGroup的值大于0，Wait方法就会阻塞。（具体实现看listing01.go）
8. 如果两个或者多个goroutine在没有互相同步的情况下，访问某个共享的资源，并试图同时读和写这个资源，就处于相互竞争的状态，这种情况就称作竞争状态（race condition）
9. 可以用竞争检测器来查找是否存在竞争状态：go build -race

## 原子函数、互斥锁
10. 锁住共享资源：Go语言提供了传统的同步goroutine的机制，就是对共享资源枷锁。原子函数能够以很底层的枷锁机制来同步访问整型变量和指针。例如atomic.AddInt64啊可以安全地累加int64值，atomic.StoreInt64可以安全地修改int64值，atomic.LoadInt64可以安全地返回int64值（具体实现可以看listing13.go，listing15.go）。
11. 另一种同步访问共享资源的方式时使用互斥锁（mutex）。互斥锁这个名字来自互斥（mutual exclusion）的概念，互斥锁用于在代码上创建一个临界区，保证同一时间只有一个goroutine可以执行这个临界区代码。（具体实现请看listing16.go）

## 通道
12. 在Go语言里，你不仅可以使用原子函数和互斥锁来保证对共享资源的安全访问以及消除竞争状态，还可以使用通道，通过发送和接受需要共享资源，在goroutine之间做同步。
13. 当一个资源需要在goroutine之间共享时，通道在goroutine之间加起来一个管道，并提供了确保同步交换数据的机制。声明通道时，需要指定要被共享的数据的类型。可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。
14. 在Go语言里，需要使用内置函数make来创建一个通道：make的第一个参数需要时关键字chan，之后跟着允许通道交换的数据的类型。如果创建的是一个有缓冲的通道，之后还需要在第二个参数指定这个通道的缓冲区的大小。向通道发送值或者指针需要用到<-操作符。具体示例如下：
```Go
// 无缓冲的整型通道
unbuffered := make(chan int)
// 有缓冲的字符串通道
buffered := make(chan string, 10)
// 通过通道发送一个字符串
buffered <- "Gopher"
// 从通道接受一个字符串
value := <-buffered
```
15. 无缓冲的通道（unbuffered channel）是指在接受前没有能力保存任何值的通道，这种类型的通道要求发送goroutine和接受goroutine同时准备好，才能完成发送和接受操作，如果没有同时准备好，通道会导致先执行发送或接受操作的goroutine阻塞等待。这种对通道进行发送或接受的交互行为本身就是同步的，其中任意一个操作都无法离开另一个操作单独存在。

# 第七章：并发模式
1. runner包用来展示如何使用通道来监视程序的执行事件，如果程序运行时间太长，也可以用runner包来终止程序
2. pool包用于展示如何使用有缓冲的通道实现资源池，来管理可以在任意数量的goroutine之间共享及独立使用的资源。这种模式在需要共享一组静态资源的情况。
3. work包的目的时展示如何使用无缓冲的通道来创建一个goroutine池，这些goroutine执行并控制一组工作，让其并发执行。

# 第八章：标准库
1. Go标准库是一组核心包，用来扩展和增强语言的能力。开发人员可以直接使用，这些包和语言绑在一起发布。不管用什么方式安装Go，标准库的源代码都会安装在$GOROOT/src/pkg文件夹中。类似godoc、gocode、gobuild这些工具，都需要读取标准库的源代码才能完成其工作。


# 第九章：测试和性能
1. go test命令可以用来执行写好的测试代码。需要做的事遵守一些规则来写测试，而且，可以将测试无缝地集成到代码工程和持续集成系统里。
2. Go语言里有几种方法写单元测试。基础测试（basic test）只使用一组参数和结果来测试一段代码，表组测试（table test）也会测试一段代码，但是会使用多组参数和结果进行测试。
3. Go语言的测试工具只会认为以_test.go结尾的文件是测试文件。如果没有那么go test运行时会报告没有测试文件。测试函数必须是公开的函数，并且以Test单词开头，而且函数的签名必须接受一个指向testing.T类型的指针，并且不返回任何值.
4. 标准库包含一个名为httptest的包，它让开发人员可以磨坊基于HTTP的网络调用。模仿（mocking）是一个很常用的技术手段，用来在运行测试时模拟访问不可用的资源。包httptest可以让你能够磨坊互联网资源的请求和响应。
5. 基准测试时一种测试代码性能的方法，想要测试解决同一问题的不同方案的性能，以及查看那种解决方案的性能更好时，基准测试就会很有用。基准测试函数必须以Benchmark开头，接受一个指向testing.B类型的指针作为唯一参数。